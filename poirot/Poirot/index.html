<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Poirot (poirot.Poirot)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">poirot</a> &#x00BB; Poirot</nav><h1>Module <code>Poirot</code></h1><p>Poirot is a grammar-based injection fuzzer for black box systems</p><dl><dt>author</dt><dd>Pierre-François Gimenez</dd></dl><nav class="toc"><ul><li><a href="#type">Type</a></li><li><a href="#main-functions">Main functions</a></li><li><a href="#oracle-functions">Oracle functions</a></li><li><a href="#grammar-manipulation-functions">Grammar manipulation functions</a></li><li><a href="#i/o-functions">I/O functions</a></li></ul></nav></header><section><header><h2 id="type"><a href="#type" class="anchor"></a>Type</h2></header><dl><dt class="spec type" id="type-grammar"><a href="#type-grammar" class="anchor"></a><code><span class="keyword">type</span> grammar</code></dt><dd><p>The grammar manipulated by Poirot</p></dd></dl><dl><dt class="spec type" id="type-element"><a href="#type-element" class="anchor"></a><code><span class="keyword">type</span> element</code></dt><dd><p>A symbol of the grammar, either a terminal or a nonterminal</p></dd></dl><dl><dt class="spec type" id="type-oracle_status"><a href="#type-oracle_status" class="anchor"></a><code><span class="keyword">type</span> oracle_status</code></dt><dd><p>A variant type describing the oracle status</p></dd></dl></section><section><header><h2 id="main-functions"><a href="#main-functions" class="anchor"></a>Main functions</h2></header><dl><dt class="spec value" id="val-search"><a href="#val-search" class="anchor"></a><code><span class="keyword">val</span> search : <span>?&#8288;verbose:bool</span> <span>&#45;&gt;</span> <span>?&#8288;subst:<span><span><span>(<a href="index.html#type-element">element</a>, string)</span> Stdlib.Hashtbl.t</span> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;max_depth:int</span> <span>&#45;&gt;</span> <span>?&#8288;forbidden_chars:<span>char list</span></span> <span>&#45;&gt;</span> <span>?&#8288;sgraph_fname:<span>string option</span></span> <span>&#45;&gt;</span> <span>?&#8288;qgraph_fname:<span>string option</span></span> <span>&#45;&gt;</span> <span>(<span>string option</span> <span>&#45;&gt;</span> <a href="index.html#type-oracle_status">oracle_status</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <span>&#45;&gt;</span> <span><a href="index.html#type-element">element</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-grammar">grammar</a> option</span></code></dt><dd><p><code>search oracle g goal start</code> returns the grammar of injection from the base grammar <code>g</code> according to the oracle <code>oracle</code>, starting from the trivial injection <code>start</code>.</p><dl><dt>parameter oracle</dt><dd><p>an oracle built with <code>make_oracle_from_script</code> or <code>make_oracle_from_fun</code></p></dd></dl><dl><dt>parameter g</dt><dd><p>the grammar of the query language (e.g. SQL)</p></dd></dl><dl><dt>parameter goal</dt><dd><p>the goal of the search, i.e. the element (terminal or nonterminal) you seek to get in the grammar of injection. Poirot stops the search once it is reached.</p></dd></dl><dl><dt>parameter start</dt><dd><p>a element (terminal or nonterminal) that is a injection.</p></dd></dl><dl><dt>parameter verbose</dt><dd><p>(optional) makes Poirot verbose when true.</p></dd></dl><dl><dt>parameter subst</dt><dd><p>(optional) an Hashtable containing the semantics substitution.</p></dd></dl><dl><dt>parameter max_depth</dt><dd><p>(optional) modify the maximal depth of the search</p></dd></dl><dl><dt>parameter forbidden_chars</dt><dd><p>(optional) a list of forbidden characters. Such characters won't be used in injection. Useful to avoid escaped characters.</p></dd></dl><dl><dt>parameter sgraph_fname</dt><dd><p>(optional, for debug) export the search graph in graphviz dot format.</p></dd></dl><dl><dt>parameter qgraph_fname</dt><dd><p>(optional, for debug) export the quotient graph in graphviz dot format.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-quotient"><a href="#val-quotient" class="anchor"></a><code><span class="keyword">val</span> quotient : <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span><a href="index.html#type-element">element</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-element">element</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>quotient g left_quotient right_quotient</code> returns the grammar <code>g</code> after a left quotient by <code>left_quotient</code> and a right quotient by <code>right_quotient</code>. <code>left_quotient</code> and <code>right_quotient</code> can contain nonterminals or be empty.</p></dd></dl><dl><dt class="spec value" id="val-fuzzer"><a href="#val-fuzzer" class="anchor"></a><code><span class="keyword">val</span> fuzzer : <span>?&#8288;subst:<span><span><span>(<a href="index.html#type-element">element</a>, string)</span> Stdlib.Hashtbl.t</span> option</span></span> <span>&#45;&gt;</span> <span>?&#8288;complexity:int</span> <span>&#45;&gt;</span> <span>?&#8288;goal:<span><a href="index.html#type-element">element</a> option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p><code>fuzzer ~complexity:10 ~goal:e g</code> returns a word from <code>g</code>. If <code>complexity</code> is high, longer words should be generated. If <code>complexity = 0</code>, the returned word is deterministic (always the same) and should be short. If a goal is specified, then it will be included in the generated word. Beware: this is a primitive fuzzer.</p></dd></dl></section><section><header><h2 id="oracle-functions"><a href="#oracle-functions" class="anchor"></a>Oracle functions</h2></header><dl><dt class="spec value" id="val-make_oracle_from_script"><a href="#val-make_oracle_from_script" class="anchor"></a><code><span class="keyword">val</span> make_oracle_from_script : <span>?&#8288;verbose:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>string option</span> <span>&#45;&gt;</span> <a href="index.html#type-oracle_status">oracle_status</a></code></dt><dd><p><code>make_oracle_from_script filename</code> returns an oracle based on the script <code>filename</code>. The script must return error code 0 if the injection is lexically correct, 1 otherwise.</p></dd></dl><dl><dt class="spec value" id="val-make_oracle_from_fun"><a href="#val-make_oracle_from_fun" class="anchor"></a><code><span class="keyword">val</span> make_oracle_from_fun : <span>?&#8288;verbose:bool</span> <span>&#45;&gt;</span> <span>(string <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span>string option</span> <span>&#45;&gt;</span> <a href="index.html#type-oracle_status">oracle_status</a></code></dt><dd><p><code>make_oracle_from_fun f</code> returns an oracle based on the function <code>f</code>. The function must return 0 if the injection is lexically correct, 1 otherwise.</p></dd></dl></section><section><header><h2 id="grammar-manipulation-functions"><a href="#grammar-manipulation-functions" class="anchor"></a>Grammar manipulation functions</h2></header><dl><dt class="spec value" id="val-to_uppercase"><a href="#val-to_uppercase" class="anchor"></a><code><span class="keyword">val</span> to_uppercase : <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>to_uppercase g</code> returns the grammar <code>g</code> with uppercased chars. The grammar is simplified, and nonterminals may disappear.</p></dd></dl><dl><dt class="spec value" id="val-to_lowercase"><a href="#val-to_lowercase" class="anchor"></a><code><span class="keyword">val</span> to_lowercase : <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>to_lowercase g</code> returns the grammar <code>g</code> with lowercased chars. The grammar is simplified, and nonterminals may disappear.</p></dd></dl><dl><dt class="spec value" id="val-set_axiom"><a href="#val-set_axiom" class="anchor"></a><code><span class="keyword">val</span> set_axiom : <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> <a href="index.html#type-element">element</a> <span>&#45;&gt;</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>set_axiom g new_axiom</code> modifies the axiom of <code>g</code> with <code>new_axiom</code>.</p></dd></dl><dl><dt class="spec value" id="val-string_of_grammar"><a href="#val-string_of_grammar" class="anchor"></a><code><span class="keyword">val</span> string_of_grammar : <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>string_of_grammar g</code> returns the string representation of <code>g</code>.</p></dd></dl></section><section><header><h2 id="i/o-functions"><a href="#i/o-functions" class="anchor"></a>I/O functions</h2></header><dl><dt class="spec value" id="val-read_bnf_grammar"><a href="#val-read_bnf_grammar" class="anchor"></a><code><span class="keyword">val</span> read_bnf_grammar : <span>?&#8288;unravel:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-grammar">grammar</a></code></dt><dd><p><code>read_bnf_grammar filename</code> reads a grammar from a bnf file <code>filename</code>.</p></dd></dl><dl><dt class="spec value" id="val-read_tokens"><a href="#val-read_tokens" class="anchor"></a><code><span class="keyword">val</span> read_tokens : <span>?&#8288;unravel:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><a href="index.html#type-element">element</a> list</span></code></dt><dd><p><code>read_tokens str</code> reads a list of element from a string <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-read_token"><a href="#val-read_token" class="anchor"></a><code><span class="keyword">val</span> read_token : <span>?&#8288;unravel:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-element">element</a></code></dt><dd><p><code>read_token str</code> reads an element from a string <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-export_antlr4"><a href="#val-export_antlr4" class="anchor"></a><code><span class="keyword">val</span> export_antlr4 : string <span>&#45;&gt;</span> <a href="index.html#type-grammar">grammar</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>export_antlr4 filename g</code> export the grammar <code>g</code> to antlr4 format into the file <code>filename</code>.g4</p></dd></dl><dl><dt class="spec value" id="val-read_subst"><a href="#val-read_subst" class="anchor"></a><code><span class="keyword">val</span> read_subst : string <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-element">element</a>, string)</span> Stdlib.Hashtbl.t</span></code></dt><dd><p><code>read_subst filename</code> read the semantics substitution from the file <code>filename</code>.</p></dd></dl></section></div></body></html>