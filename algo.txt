Entrées :
    L = liste de token initiaux possibles
    G = grammaire du langage cible

Hashtable: associe un ext_element à une liste de ext_rule

Algo:
    Initialise la hashtable avec la grammaire initiale
    Initialise l'open set avec L
    Tant que l'open set n'est pas vide
        Récupère le token/pre/suf de meilleur score (l'état) et la règle triviale qui va avec. Le meilleur triplet est celui qui minimise g+h. En cas d'égalité, prendre le h minimal.
        Si l'état ne fait pas déjà parti du closed set
            on ajoute l'état au closed set
            Si T est non-terminal:
                Pour chaque règle qui a T dans sa partie droite, on calcule récursivement sa grammaire avec le préfixe et le suffixe (en l'ajoutant à la hashtable, avec pour clé l'état courant)
                Lors de cette construction de grammaire, on vérifie que le calcul du quotient n'est pas impossible (pour cela, utiliser la table des préfixes/suffixes des nonterminaux)
                Retirer les règles superflues (avec symboles inutiles), mais toujours garder la clé dans la hashtable pour montrer que ça a été traité.
                S'il n'y a que la règle triviale associée à l'état, il est intestable.
                Si l'objectif est atteignable : on fuzze des phrases avec l'objectif (l'état est forcément testable dans ce cas, sinon on aurait déjà atteint l'objectif à l'état parent)
                Si l'état est testable:
                    On génère sa grammaire pour le fuzzer en évitant la règle triviale de l'état courant. On ajoute toutes les autres règles triviales.
                    On teste avec le fuzzer si sa grammaire est correcte.

            Si T est terminal ou si l'état n'a pas été invalidé par fuzzer:
                On récupère les règles qui peuvent donner ce token T
                On construit, pour chaque règle a -> p T s, un nouveau triplet a/p+pre/suf+s (la règle utilisée est mémorisée)
                On note, pour chaque triplet, la distance à la cible, et on ajoute à la liste (open set de A*)

Optimisation:
utiliser un tas binaire pour l'open set
Tester avec une heuristique non-admissible, comme 3*h ?

Programmation dynamique:
quand on calcule le quotient, on peut se rapporter à des sous-grammaires. Cf. algo carnet

Preuve de convergence:
Il y a un arbre réel, et donc un chemin existant. À chaque étape, le triplet est valide. Donc on pourra aboutir à l'arbre réel, et donc à la vraie grammaire.

Complexité:
Exponentielle au pire (à montrer avec exemple)
